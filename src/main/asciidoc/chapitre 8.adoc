Chapitre 8

Maven et JavaEE
---------------

Notre application noubliepaslalistedescourses est fin prête pour une
ouverture au public. Nous ne disposons cependant pas de nos propres
serveurs et faisons appel à un hébergeur. Celui-ci nous propose un
magnifique service d'hébergement JavaEE surveillé 24 heures sur 24 par
une équipe de spécialistes. Autant laisser faire les pros. Chacun son
métier !

Le monde de Java côté serveur est un monde en "AR" : JAR, WAR, RAR, EAR
se côtoient dans un ballet un peu déconcertant d'archives Java et de
descripteurs de déploiement. Souvent décrié, le modèle JavaEE est
pourtant solidement implanté et continue de progresser avec une refonte
significative dans sa mouture JavaEE6. Maven ne pouvait pas faire
l'impasse sur ce modèle, sur ses limites et sur les bonnes pratiques de
développement qui l'accompagnent.

Java Entreprise Edition
~~~~~~~~~~~~~~~~~~~~~~~

Le modèle JavaEE n'a pas très bonne réputation. Il définit (entre
autres) deux rôles spécialisés : le développeur et l'assembleur de
composants. Ce dernier est chargé de définir, _via_ des descripteurs de
déploiement, la façon dont des macrocomposants sont liés au sein d'une
application d'entreprise. Ces macrocomposants, ce sont les EJB,
connecteurs et applications web que nous devons regrouper dans une
archive d'entreprise EAR. Les descripteurs, ce sont ces (trop ?)
nombreux fichiers XML dans lesquels nous déclarons des références vers
d'autres composants ou vers des ressources du serveur (typiquement, une
base de données). Nous y enregistrons aussi l'identité de chaque
composant pour sa parution dans un annuaire JNDI. La Figure 08-01 résume
cette structure. Si vous n'êtes pas familier avec la norme JavaEE ou si
vous voulez en avoir une description plus fine et moins biaisée que
notre résumé de quelques lignes, nous vous recommandons l'introduction
disponible sur le site de SUNlink:#_ftn31[[31]].

Figure 08-01

Structure d'une application selon le modèle JavaEE.

Cette structure soulève de nombreuses critiques, qui ne sont pas l'objet
de ce livre. Nous ne nous attarderons donc pas dessus. Quoi qu'on en
pense, JavaEE est une norme largement implantée et supportée, et il nous
faut la suivre d'une façon ou d'une autre si nous voulons déployer notre
belle application sur le serveur d’hébergement.

Info

Java EE, J2EE ou JEE ? Pour une raison obscure, java 1.2 a été annoncé
par SUN sous le nom de « Java 2 ». En ont découlé les versions standard
J2SE, mobile J2ME et entreprise J2EE. Dans un élan de logique, les
versions suivantes on conservé ce nom en ajoutant un numéro de version,
on a donc eu le droit à J2EE 1.3 puis J2EE 1.4. Ce n’est qu’avec la
version 1.5 que SUN a changé de politique pour nommer son bébé « Java
5 ». Au passage, la déclinaison entreprise est devenue JavaEE 5, puis
JavaEE 6.

Seul soucis, prononcé rapidement,  J2EE « Ji-deux-eeuuh » devient
rapidement JEE, au même titre qu’on dit « ès-ès-deux-i » pour l’acronyme
SSII. On voit donc dans de nombreux CV ou offres d’emploi le terme JEE
qui ne correspond à rien. Ceci dit, cela ne change absolument rien et
tout le monde comprend de quoi on parle, mais c’était l’occasion de
faire un petit point culturel :)

Construire une archive web WAR
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

La première étape consiste à créer l'archive WAR de notre application
web, en incluant son descripteur de déploiement. En tant que fichier
binaire, un WAR n'est rien d'autre qu'une archive JAR avec une extension
spécifique, donc rien de bien compliqué. Nous devons cependant suivre la
structure définie par la norme JavaEE, en particulier le répertoire
WEB-INF qui doit contenir :

·     le descripteur de déploiement web.xml ;

·     un sous-répertoire classes avec le code compilé de nos servlets et
des autres classes nécessaires à notre application ;

·     un sous-répertoire lib avec les bibliothèques utilisées.

Sur un projet utilisant un répertoire lib fourre-tout pour placer ses
bibliothèques, le troisième point serait traité avant même qu'on ne se
pose la question, mais sur notre projet Maven ?

image:illustrations/MangaVincentS.png[float="left"]

Vincent s'attaque à la construction automatisée de notre WAR. Il trouve
rapidement un allié de choix dans le plugin war de Maven. Celui-ci a été
conçu pour répondre de la manière la plus souple et la plus transparente
qui soit à ces contraintes d'assemblage. Ce plugin va bâtir dans le
répertoire de construction (target) la structure ouverte de l'archive
WAR à partir des éléments de notre projet et de nos déclarations dans le
POM. Il va donc y recopier tous les éléments statiques de notre
application web (pages html, images, scripts…), ainsi que nos classes
compilées par le plugin compiler, notre descripteur de déploiement et
nos bibliothèques – du tout cuit !

Cerise sur le gâteau, Vincent n'a même pas besoin de déclarer
explicitement ce plugin comme nous l'avons fait jusqu'ici : puisque
notre projet ne produit pas un JAR, il remplace la déclaration de
<packaging> pour indiquer la construction d'une archive WAR. Ce
packaging, supporté par défaut par Maven, provoque automatiquement une
sélection différente des plugins associés par défaut aux phases du
projet, et en particulier l'activation du plugin war lors de
l'assemblage.

Vincent aurait-il tiré le gros lot en prenant en charge cette tâche ?
Une ligne de configuration à éditer en tout et pour tout, c'est plutôt
reposant ! Eh bien non ! Au lancement de notre application sur le
serveur de test Tomcat, nous avons droit à une erreur qui pourrait faire
sourire si nous étions un 1^er^ avril, mais qui nous laisse perplexes :

ClassCastException :
fr.noubliepaslalistedescourses.servlets.LoginServlet is not a
javax.servlet.Servlet

Nous devons explorer un peu plus la logique de JavaEE pour comprendre.
Un serveur JavaEE isole chacun des composants qu'on y déploie afin
qu'ils ne se perturbent pas mutuellement. Cette isolation se fait _via_
des chargeurs de classes dédiés. Notre application web aura donc son
propre chargeur de classes, incluant les bibliothèques de notre
WEB-INF/lib et nos classes de WEB-INF/classes. Celui-ci hérite d'un
chargeur père qui contient les classes du serveur d'application
permettant la mise en œuvre de l'API servlet. Le serveur sera donc en
mesure de manipuler nos servlets parce que nous partageons avec lui les
classes de cette API. La Figure 08-02 compare cependant ce modèle
théorique et ce que nous observons.

Figure 08-02

Comparaison de la structure des chargeurs de classes : théorie _vs_
pratique.

Lorsque le serveur d'application tente d'initialiser un de nos servlets,
il manipule tout naturellement le type javax.servlet.Servlet, à partir
des classes présentes dans son chargeur de classes. Notre servlet
LoginServlet a cependant été instancié dans le chargeur de classes de
l'application web ; aussi, pour que tout fonctionne bien, il faut que le
type javax.servlet.Servlet, lorsqu'il est manipulé depuis l'application
web, soit le même que depuis le code du serveur d'application.

En jetant un coup d'œil à notre WEB-INF/lib, nous y découvrons le
coupable : servlet-api-2.5.jar. Un servlet créé dans notre application
web aura comme type parent une classe qui est chargée elle aussi par
l'application web, et pas le javax.servlet.Servlet commun à tout le
serveur d'application. D'où cet étrange message d'erreur. Vincent est
rassuré sur sa santé mentale.

Info

Lorsqu'il s'agit du JAR de l'API servlet le constat est rapide, mais il
peut arriver qu'une bibliothèque ait la mauvaise idée de contenir les
classes d'une API Java (plutôt que d'en dépendre), comme par exemple le
JAR gwt-user de GWT. L'identification du coupable est alors nettement
moins immédiate.

Cette dépendance javax.servlet:servlet-api:2.5 est pourtant
indispensable à notre application pour qu’elle soit en mesure de
compiler. Nous faisons de nombreuses références directes à ces classes
dans notre code ! Nous avons déjà exploré les scopes que nous pouvons
affecter à nos dépendances. Le scope par défaut (compile) signifie que
la bibliothèque associée est nécessaire pour compiler et s'exécuter,
c'est donc _a priori_bien le cas. Il existe cependant un autre scope,
provided, qui est très proche avec une nuance significative : il déclare
une dépendance nécessaire pour compiler et s'exécuter mais qui est
fournie par l'environnement d'exécution, typiquement notre serveur
JavaEE.

La modification suivante sur nos dépendances corrige donc ce problème
assez déboussolant et nous permet enfin de lancer l'application web sur
notre serveur Tomcat.

<dependency>

    <groupId>javax.servlet</groupId>

    <artifactId>servlet-api</artifacId>

    <version>2.5</version>

    <scope>provided</scope>

</dependency>

Construire un EJB
^^^^^^^^^^^^^^^^^

Notre exploration du monde JavaEE se poursuit avec un Entreprise Java
Bean, c'est-à-dire un macrocomposant métier qui sera potentiellement
distribuable sur l'ensemble de notre cluster.

Info

Quoi, nous n'avons pas de cluster ? Pourquoi avoir choisi un EJB alors ?
Sans vouloir faire de l'anti-JavaEE, disons que les EJB ont longtemps
traîné de lourdes casseroles car ils étaient appliqués sans qu’on en
comprenne le rôle dans l'architecture. Jusqu'à l'émergence de JavaEE5 et
de JavaEE6, qui les dépoussièrent sensiblement, leur utilisation était
même largement décriée au profit de modèles légers dont SpringFramework
est le fer de lance.

image:illustrations/MangaVincentS.png[float="left"]

Nous avons donc isolé notre code métier dans un module (voir le
Chapitre 7) dédié, chargé de construire un composant réutilisable. Fort
de son précédent succès, Vincent se porte volontaire pour explorer la
"mavenisation" de cet aspect de notre application.

La même recette donne le même résultat, ce qui finit par nous faire
penser que Vincent a décidément le nez fin : <packaging>ejb</packaging>
dans le POM suffit pour changer la configuration par défaut du cycle de
vie et produire un EJB. La seule chose que nous devrons y ajouter est la
configuration de la version de l'API EJB que nous voulons utiliser, à
savoir EJB3 ce qui n'est pas la valeur par défaut (2.1).

<plugin>

    <groupId>org.apache.maven.plugins</groupId>

    <artifactId>maven-ejb-plugin</artifactId>

    <version>2.1</version>

    <configuration>

          <ejbVersion>3.0</ejbVersion>

    </configuration>

</plugin>

Cette formalité passée, nous obtenons l'EJB tant attendu, dont nous
pouvons tester le déploiement sur un serveur de test OpenEJB.

Il nous reste à faire le lien avec notre application web. Celle-ci doit
disposer des classes client de l'EJB, c'est-à-dire de la partie de l'EJB
qui définit son utilisation (interfaces, objets paramètres). Cela ne va
pas nous coûter beaucoup d'efforts puisque le plugin ejb a la bonne idée
de créer une archive avec ces classes pour nous, en ajoutant simplement
à sa configuration <generateClient>true</generateClient>. Nous obtenons
donc au final deux archives Java :

·     noubliepaslalistedescourses-ejb-1.0.0-SNAPSHOT.jar, notre fameux
EJB ;

·     noubliepaslalistedescourses-ejb-1.0.0-SNAPSHOT-client.jar,
l'archive des classes client qui permettra d'invoquer notre EJB.

Dans notre application web, il nous suffit donc de déclarer une nouvelle
dépendance vers ce client pour pouvoir utiliser notre EJB :

<dependency>

      <groupId>fr.noubliepaslalistedescourses</groupId>

      <artifactId>noubliepaslalistedescourses-ejb</artifactId>

      <version>1.0.0-SNAPSHOT</version>

      <type>ejb-client</type>

</dependency>

Reste à faire le lien entre les deux composants, _via_ les descripteurs
de déploiement. L'objet de ce livre n'est pas de vous faire un exposé
complet sur JavaEE ; pourtant, nous ne pouvons pas honnêtement vous
laisser sans réponse si près du but… Les Listings 8.1 et 8.2 montrent
les deux descripteurs de déploiement de notre application, le premier
permettant à l'EJB de s'identifier et de demander une ressource de type
base de données, le second permettant à l'application Web d'obtenir une
référence vers notre EJB, potentiellement installé sur un autre serveur,
voire distribué sur un cluster.

Listing 8.1 : Descripteur de déploiement de notre EJB

<?xml version="1.0"?>

<!DOCTYPE ejb-jar PUBLIC

   '-//Sun Microsystems, Inc.//DTD Enterprise JavaBeans 1.1//EN'

   'http://java.sun.com/j2ee/dtds/ejb-jar_1_1.dtd'>

 

<ejb-jar>

   <enterprise-beans>

 

      <session>

         <ejb-name>ListeDeCoursesEJB</ejb-name>

         <home>

            fr.noubliepaslalistedescourses.ListeDeCoursesHome

         </home>

         <remote>

            fr.noubliepaslalistedescourses.ListeDeCourses

         </remote>

         <ejb-class>

            fr.noubliepaslalistedescourses.ListeDeCoursesBean

         </ejb-class>

         <session-type>Stateless</session-type>

         <transaction-type>Container</transaction-type>

 

         <resource-ref>

            <res-ref-name>jdbc/appDB</res-ref-name>

            <res-type>javax.sql.DataSource</res-type>

            <res-auth>Container</res-auth>

            <description>

               Accès JDBC à la base de données

            </description>

         </resource-ref>

      </session>

 

   </enterprise-beans>

</ejb-jar>

Listing 8.2 : Descripteur de déploiement de notre application web

<?xml version=_"1.0"_ encoding=_"UTF-8"_?>

 

<web-app version=_"2.4"_

    xmlns=_"http://java.sun.com/xml/ns/j2ee"_

    xmlns:xsi=_"http://www.w3.org/2001/XMLSchema-instance"_

    xsi:schemaLocation=_"http://java.sun.com/xml/ns/j2ee_

_                       
http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"_>

 

  < !-- Servlet GWT-RPC de l'application web -->

  <servlet>

    <servlet-name>gwt-rpc</servlet-name>

    <servlet-class>

      org.springframework.web.servlet.DispatcherServlet

    </servlet-class>

    <load-on-startup>1</load-on-startup>

  </servlet>

 

  <servlet-mapping>

    <servlet-name>gwt-rpc</servlet-name>

    <url-pattern>*.rpc</url-pattern>

  </servlet-mapping>

 

  < !—Référence vers notre EJB -->

  <ejb-ref>

    <ejb-ref-name>ejb/ListeDeCourses</ejb-ref-name>

    <ejb-ref-type>Session</ejb-ref-type>

    <ejb-ref-home>

       fr.noubliepaslalistedescourses.ListeDeCoursesHome

    </ejb-ref-home>

    <ejb-ref-remote>

       fr.noubliepaslalistedescourses.ListeDeCoursesRemote

    </ejb-ref-remote>

  </ejb-ref>

</web-app>

Construire une archive d'entreprise EAR
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Il ne nous reste plus qu'à prendre nos composants et à les grouper dans
un joli paquet-cadeau avant de l'envoyer à notre hébergeur. En terme
JavaEE le paquet-cadeau est une archive d'entreprise EAR.

image:illustrations/MangaVincenTS.png[float="left"]

Pour produire ce nouvel artefact, Vincent applique la recette qui lui a
jusqu'ici réussi et fait mouche une nouvelle fois : un nouveau module,
avec comme packaging ear suffit pour produire un artefact EAR. Si tout
pouvait être aussi simple… enfin, passons.

La seule chose à déclarer dans le POM de ce nouveau module est la liste
de dépendances, pointant vers nos composants JavaEE, à inclure dans
l'EAR – dans notre cas, l'application web et l'EJB, mais potentiellement
plusieurs composants de ce type et/ou des connecteurs RAR ou autres
subtilités JavaEE propriétaires ou non.

Le plugin ear compte de nombreuses options qui permettent d'ajuster
finement le nom de chaque composant à l'intérieur de l'archive EAR. Il
propose même de générer pour nous le descripteur de déploiement
application.xml, ce qui nous fera toujours un fichier de moins à
maintenir.

Nous avons un bel EAR prêt pour une mise en production, cependant un
détail chagrine Vincent : notre application web, comme notre EJB,
utilise plusieurs bibliothèques utilitaires, telles que commons-lang ou
commons-io. Dans sa structure actuelle, nous retrouvons ces fichiers en
double, une fois dans le WEB-INF/lib de l'application web, une fois dans
le fichier EJB. Ce n'est pas intellectuellement très satisfaisant.

Le modèle JavaEE a prévu le découpage des composants en modules mais n'a
pas non plus négligé la mutualisation des bibliothèques. Le métafichier
MANIFEST permet de déclarer des bibliothèques nécessaires à l'exécution
d'un module JavaEE, bibliothèques qui seront alors mises à disposition
_via_ l'EAR.

Maven n'a pas non plus négligé cet aspect du packaging JavaEE, et nous
devons revenir dans notre projet application web pour marquer les
dépendances que nous voulons à présent exclure de WEB-INF/lib pour les
mutualiser.

À la première étape, on demande au plugin war de construire, dans les
métadonnées de l'archive, l'indication de classpath :

      <plugin>

        <groupId>org.apache.maven.plugins</groupId>

        <artifactId>maven-war-plugin</artifactId>

        <version>2.0.2</version>

        <configuration>

          <archive>

            <manifest>

              <addClasspath>true</addClasspath>

            </manifest>

          </archive>

        </configuration>

      </plugin>

Pour chaque dépendance que nous voulons voir apparaître dans ce chemin
de classes commun, et donc exclure de notre WEB-INF/lib, il suffit
d'indiquer le statut optionnel de la dépendance :
<optional>true</optional>. La déclaration peut sembler un peu
contre-nature, puisque dans la majorité des cas la dépendance en
question n'est pas du tout optionnelle. Il s'agit, avouons-le, d'un
détournement de la notion de dépendance optionnelle, qui, de toute
façon, n'a pas vraiment de sens pour un projet WAR.

Dans notre projet EJB, nous appliquons au plugin ejb la même déclaration
<archive> que pour le plugin war. L'EJB produit aura alors dans son
MANIFEST une déclaration de classpath à la place de l'inclusion de ses
dépendances. Il ne nous reste plus qu'à déclarer ces dépendances dans
notre projet EAR pour que celui-ci les intègre dans l'archive EAR et
qu'elles soient ainsi partagées entre nos deux composants JavaEE.

Pour éviter un travail fastidieux de cohérence entre les trois modules,
nous remontons dans le projet parent ces déclarations de dépendances,
qui deviennent alors elles-mêmes mutualisées. Comme déclaration de
dépendances, notre projet application web ne contient alors que les
bibliothèques spécifiquement web qu'il emploie. La Figure 08-03 indique
la structure finale de notre projet Maven.

Figure 08-03

Multiprojet JavaEE avec mise en commun des dépendances _via_ l'EAR.

Tester
~~~~~~

image:illustrations/MangaVincentS.png[float="left"]

Nous savons désormais construire notre archive d'entreprise en une seule
ligne de commande, respectant à la lettre la spécification JavaEE. Mais
Vincent ne veut pas en rester là : _quid_ des tests de nos composants ?
En particulier, si nous savons les tester unitairement ou à un niveau
intégration (voir le Chapitre 5), la partie web reste le parent pauvre.
Par définition, nos pages web produites par des JSP, composants JSF ou
servlets, ne peuvent être testées que lorsqu'elles sont hébergées par un
serveur JavaEE ou, au minimum, un moteur de servlet. Comment contrôler
le bon enchaînement de nos pages, la remontée correcte des données, le
fonctionnement global de notre application ?

Ce dont Vincent rêve, c'est d'un outil qui ferait ce que nous devons
faire à la main à chaque modification du code : assembler l'application,
la déployer sur un serveur de test, la démarrer, puis lancer notre
navigateur et enchaîner quelques écrans pour constater le rendu HTML
d'une page particulière. Eh bien réjouissons-nous, cet outil de rêve
existe !

Selenium
^^^^^^^^

Seleniumlink:#_ftn32[[32]] est un outil qui n'est pas limité au monde
Java mais s'y intègre très bien. Il s'agit d'un système complet
d'enregistrement et de pilotage du navigateur web à des fins de test –
rien que ça.

Il se compose de deux parties :

·     Un enregistreur, qui se base sur le navigateur Firefox et permet
de capturer une séquence d'actions sur ce dernier. Vous enregistrez
ainsi un scénario d'utilisation type de votre application.

·     Un outil de pilotage, qui va rejouer le scénario enregistré sur un
navigateur. Selenium lance et dirige le navigateur de votre
environnement, remplaçant l'utilisateur humain.

Le grand intérêt de cette approche par rapport à de nombreux autres
outils de test est que l'on peut tester une application web dans un
véritable navigateur, avec ses particularités, ses bogues, sa façon bien
à lui d'interpréter les balises HTML et le code JavaScript.

L'enregistreur peut sauvegarder le scénario de test selon de nombreux
formats, dont deux vont particulièrement nous intéresser. Le premier est
une simple table HTML, listant les actions réalisées sur le navigateur
(cliquer, attendre la page suivante…). Le second utilise notre bon vieux
langage Java et le framework de test jUnit. Cette seconde option nous
permet d’éditer le scénario pour y ajouter les contrôles qui nous
plaisent en utilisant notre langage de programmation habituel. Nous
n'avons donc pas à apprendre les secrets d'un nouveau langage !

Le Listing 8.3 montre le code d'un test Selenium utilisant la syntaxe
Java. Du point de vue du programmeur, l'API de Selenium offre une vision
de très haut niveau du navigateur sous contrôle, ce qui rend la
programmation très rapide et agréable.

Listing 8.3 : Test Selenium en syntaxe Java

import com.thoughtworks.selenium.*;

import junit.framework.*;

import java.util.regex.Pattern;

 

public class SimpleTest extends SeleneseTestCase

\{

    public void setUp()

    \{

        setUp( "http://localhost:8080/", "*iexplore" );

        selenium.open( "noubliepaslalistedescourses.home" );

    }

 

    public void testLogin()

    \{

        selenium.type( "login", "Vincent" );

        selenium.click( "submit" );

        selenium.waitForPageToLoad( "5000" );

        assertTrue( selenium.isElementPresent( "salut" ) );

    }

}

Si la syntaxe du test est celle de jUnit, l'exécution d'un test Selenium
nécessite un peu plus que le simple framework de test. Selenium repose
sur un composant contrôleur, chargé de lancer le navigateur de la
machine hôte et d'en piloter le comportement. Nous devons donc intégrer
le démarrage de ce contrôleur dans notre processus de construction Maven
si nous voulons en exploiter la puissance :

·     *Démarrer la* partie serveur (le contrôleur) de Selenium. Elle va
permettre de faire le lien entre le test et le navigateur.

·     Lancer le navigateur disponible sur la plateforme.

·     *Exécuter le test* sur le navigateur sous le contrôle du serveur.

·     Collecter le résultat du test et le consolider pour l'intégrer
dans les comptes-rendus d'exécution de Maven (et faire échouer le build
si les tests ne passent pas).

·     *Fermer le navigateur* et arrêter le serveur pour libérer
correctement les ressources de la machine hôte.

Le plugin selenium vient à notre secours : il propose deux tâches
complémentaires, chargées de faire démarrer et d'arrêter proprement le
contrôleur Selenium, respectivement au cours des phases
pre-integration-test et post-integration-test. Ce qui nous laisse donc
la phase integration-test pour exécuter nos tests, comme ça tombe bien !

Nous l'avons vu, Selenium peut stocker les scénarios sous forme de
fichiers HTML. Le plugin selenium propose une tâche dédiée à ce format
qui permet de les exécuter au cours du build Maven. Il est donc facile
d'outiller une application de tests de non-régression : il suffit
d'enregistrer des scénarios au format HTML et d'ajouter la configuration
du Listing 8.4 ; les tests seront alors rejoués à l'identique à chaque
construction complète du projet.

Listing 8.4 : Configuration du plugin Selenium

<plugin>

    <groupId>org.codehaus.mojo</groupId>

    <artifactId>selenium-maven-plugin</artifactId>

    <version>1.0-rc-1</version>

    <executions>

      <execution>

        <phase>integration-test</phase>

        <goals>

          <goal>selenese</goal>

        </goals>

      </execution>

    </executions>

    <configuration>

      <browser>*firefox</browser>

      <startURL>localhost:8080/myApp</startURL>

      <suite>src/test/selenium/suite.html</suite>

    </configuration>

  </plugin>

La seconde option, fondée sur l'enregistrement et l'enrichissement
éventuel de nos scénarii de test au format jUnit, va utiliser le plugin
standard surefire pour l'exécution des tests. Il sera simplement
configuré de manière spécifique pour s'exécuter lors de la phase
integration-test.

image:illustrations/MangaVincentS.png[float="left"]

Magique ! Vincent s'empresse d'ajouter à notre projet le plugin surefire
– qui prend en charge l'exécution de tests jUnit – et de l'associer à
cette phase de test d'intégration. Sitôt dit, sitôt fait, mais là gros
problème : nos tests sont exécutés avant que le contrôleur Selenium ne
démarre. Nous l'avions oublié, mais Surefire est déjà configuré pour
s'exécuter au cours de la construction de notre projet, car c'est lui
qui est chargé de l'exécution de nos tests unitaires, et il ne sait pas
différencier sans notre aide les tests Selenium des tests plus
classiques.

Une première solution est d'utiliser des règles de nommage pour
différencier facilement les deux catégories de tests. Nous n'avons alors
qu'à configurer Surefire avec des patrons complémentaires
d'inclusion/exclusion pour que chaque test se déroule dans la phase
adéquate. Le Listing 8.5 montre la configuration dans le fichier POM qui
met en œuvre cette stratégie. Les tests Selenium sont suffixés Selenium
au lieu de Test pour les différencier.

Listing 8.5 : Configuration du plugin Surefire pour exécuter nos tests
Selenium

  <plugin>

    <artifactId>maven-surefire-plugin</artifactId>

    <executions>

      <execution>

       <id>integration-test</id>

       <goals>

         <goal>test</goal>

       </goals>

       <phase>integration-test</phase>

       <configuration>

         <includes>

           <include>**/*Selenium.java</include>

         </includes>

       </configuration>

      </execution>

    </executions>

  </plugin>

Une autre solution consiste à créer un second projet, destiné aux tests
d'intégration, dans lequel nous les placerons, ce qui évite toute
ambiguïté. La configuration est alors plus simple, et nous disposons
d'un emplacement dédié pour la définition de nos tests d'intégration.

Les deux approches sont valides et couramment appliquées selon les goûts
de chacun. La première utilise de manière assez logique les phases
*integrations-test de Maven, la seconde isole cette catégorie de tests
un peu hors normes dans un projet dédié qui concerne une catégorie
différente de développeurs.

Nous savons donc lancer un navigateur et lui faire suivre un scénario
prédéfini. Reste à le faire pointer vers notre application. Mais au
fait, où est-elle notre application ? Nous avons bien une archive WAR,
mais sans serveur où la déployer, elle n’affichera jamais de page HTML !

Cargo
^^^^^

Cargolink:#_ftn33[[33]] est un autre outil majeur pour notre boîte à
outils de test. Son objectif est de prendre en charge l'installation
d'un serveur JavaEE, sa configuration, son démarrage et le déploiement
de composants JavaEE, le tout pour tous les serveurs existants (à
l'exception notable de Websphere, récalcitrant à toutes les tentatives)
et _via_ une API simple et homogène – vaste programme !

Dans notre cas, nous allons utiliser Cargo pour exécuter notre
application sur un serveur JBoss. L'automatisation qu’offre cet outil
par le biais de son plugin Maven est telle qu'il propose de télécharger
pour nous le ZIP de ce serveur, de l'installer dans un répertoire
temporaire et d'en configurer une instance à la demande lors de la
construction de notre projet. Tout ça en une seule ligne de commande,
c'est tout de même pas mal. Bien sûr, la configuration est un peu moins
facile que pour un plugin plus "simple" (voir Listing 8.6). Cet extrait
de notre POM définit les paramètres d'utilisation de Cargo :

·     L'exécution lors des phases pre-integration-test et
post-integration-test pour installer, configurer et démarrer puis
arrêter proprement le serveur.

·     L'identification du serveur utilisé, _via_ la clé jboss42x, et des
répertoires de travail, de log ainsi que de l'emplacement depuis lequel
l'archive sera téléchargée.

·     La configuration du serveur et de la machine virtuelle Java qui va
l'exécuter.

·     Les composants JavaEE qui seront déployés sur ce serveur avant de
passer à la phase integration-test. Nous indiquons l'artefact de notre
application web ainsi qu'un fichier XML, dans un format spécifique de
JBoss, qui nous permet de définir l'accès à notre base de données de
test.

Listing 8.6 : Configuration du plugin Cargo

<plugin>

  <!--

  Démarrage d'un serveur JBoss 4.0.2 et déploiement de l'appli web

  @see http://cargo.codehaus.org/Starting+and+stopping+a+container

   -->

  <groupId>org.codehaus.cargo</groupId>

  <artifactId>cargo-maven2-plugin</artifactId>

  <version>1.0</version>

  <executions>

    <!-- démarrage et arrêt du serveur lors d'un mvn:install -->

    <execution>

      <id>start-container</id>

      <phase>pre-integration-test</phase>

      <goals>

        <goal>start</goal>

      </goals>

    </execution>

    <execution>

      <id>stop-container</id>

      <phase>post-integration-test</phase>

      <goals>

        <goal>stop</goal>

      </goals>

    </execution>

  </executions>

  <configuration>

    <container>

      <!-- Configuration du serveur ("container") piloté par Cargo -->

      <containerId>jboss42x</containerId>

      <zipUrlInstaller>

      
 <url>http://downloads.sourceforge.net/jboss/jboss-4.0.2.zip</url>

        <installDir>$\{java.io.tmpdir}/cargoinstalls</installDir>

      </zipUrlInstaller>

      <timeout>600000</timeout>

      <output>$\{project.build.directory}/jboss42x.log</output>

      <append>true</append>

      <log>$\{project.build.directory}/cargo.log</log>

      <dependencies>

        <!-- Ajout du driver de la base de données -->

        <dependency>

          <groupId>com.oracle</groupId>

          <artifactId>ojdbc14</artifactId>

        </dependency>

      </dependencies>

    </container>

 

    <!-- Configuration du déploiement de l'application web -->

    <configuration>

      <type>standalone</type>

      <home>$\{project.build.directory}/jboss42x</home>

      <properties>

        <cargo.logging>high</cargo.logging>

        <cargo.jvmargs>

          -XX:PermSize=512m -XX:MaxPermSize=1024

          -XX:+CMSPermGenSweepingEnabled

          -XX:+CMSClassUnloadingEnabled

        </cargo.jvmargs>

<!—

   Quoi, vous ne connaissiez pas l'option CMSClassUnloadingEnabled ? ;p 

-->

      </properties>

 

      <deployables>

        <deployable>

          <!-- Déploiement d'une DataSource JDBC Oracle -->

         
<location>$\{build.testOutputDirectory}/oracle-ds.xml</location>

          <type>file</type>

        </deployable>

        <deployable>

          <!-- Déploiement de notre application web -->

          <groupId>fr.noubliepaslalistedescourses</groupId>

          <artifactId>noubliepaslalistedescourses</artifactId>

          <type>war</type>

        </deployable>

      </deployables>

    </configuration>

  </configuration>

</plugin>

image:illustrations/MangaVincentS.png[float="left"]

Après avoir ingurgité la hiérarchie un peu lourde de cette configuration
XML, Vincent lance la commande magique mvn install et constate avec
plaisir le téléchargement puis le démarrage d'un serveur JBoss sur son
environnement, et le déploiement de notre application, prête pour les
tests Selenium qui ont enfin du grain à moudre.

 

Nous nous serions bien contentés de cette solution, mais Vincent est un
perfectionniste. Tout ce XML, toute cette mécanique, pour tester un bout
de code JavaEE ça lui semble démesuré. Cargo fait très bien son boulot,
mais n’est qu’un outil de déploiement. Il faut lui greffer une bonne
dose de complexité pour en faire un outil de pilotage de nos tests
d’intégration.

 

Notre projet EJB est un élément assez délicat à tester confortablement.
Le cycle de vie de l'EJB doit être respecté pour que son code fonctionne
et il repose sur la fourniture par l'environnement de ressources gérées
par le serveur. Nous avons découpé notre code pour pouvoir tester
unitairement les aspects essentiels, mais nous voudrions pouvoir
l’exécuter en mode EJB réel, au moins pour quelques tests d’intégration.

Une fois de plus, la force d'une norme comme JavaEE va apporter des
solutions. Comme nous ne développons pas du code dépendant d'un serveur
particulier, nous pouvons le changer d'environnement pour le tester. La
portabilité est garantie par la certification JavaEE qui valide le
respect de la norme par chaque serveur JavaEE candidat.

OpenEJB nous propose de déployer notre EJB dans un environnement
particulièrement léger, à tel point qu'on peut facilement l'intégrer
dans un test unitaire. La seule chose que nous ayons à faire, c'est de
lancer l'annuaire JNDI d'OpenEJB, qui se chargera automatiquement dans
la foulée. Le Listing 8.7 montre, par exemple, le code excessivement
complexe J qui permet de lancer notre EJB au sein d'un test unitaire.

Listing 8.7 : Lancement d'OpenEJB embarqué dans un test

@Test

Public void testMonEJB() throws Exception

\{

    Properties p = new Properties();

    p.setProperty( Context.INITIAL_CONTEXT_FACTORY,

        "org.apache.openejb.client.LocalInitialContextFactory" );

     InitialContext ctx = new InitialContext( p );

     MonEjb ejb = (MonEjb) ctx.lookup( "MonEJBLocalBean" );

     // Test sur l'ejb...

}

Plus d'excuses pour ne pas développer une couverture de test de qualité
autour de nos composants métier !

Ce dernier exemple montre qu'il ne faut pas tout attendre des plugins
Maven, et que de nombreux outils fournissent des moyens de tester notre
code dans des conditions confortables directement depuis nos tests
jUnit. Le déploiement sur un serveur, même piloté par Cargo, reste une
opération lourde que nous réservons aux tests fonctionnels ou aux tests
de charge.

Arquillian
~~~~~~~~~~

image:illustrations/MangaVincentS.png[float="left"]

Vincent n’est cependant pas totalement satisfait de devoir tester du
code destiné à JBoss (notre serveur de production) sur OpenEJB. Certes
la norme JavaEE définit le comportement attendu sur tous les serveurs
certifiés, mais la pratique réserve généralement de mauvaises surprises,
et nous voudrions éviter de nous en rendre compte le jour de la mise en
production.

Vincent nous déniche alors un projet prometteur : JBoss Arquillian.
Conçu comme un outil de test, Arquillian prend en charge
l’instrumentation des tests, le déploiement sur le serveur et la capture
des résultats. Du tout en un, avec en plus une petite dose de modernité
qui fait défaut à Cargo : la possibilité de faire fonctionner le serveur
en mode embarqué, accélérant sensiblement les tests.

 

Reprenons donc notre EJB ListeDeCoursesBean, et faisons appel à
Arquillian pour le tester sur un serveur JBoss. Du côté de notre bluid
Maven, l’ajout de la dépendance adéquate s’impose d’elle même :

<dependency>

   <groupId>org.jboss.arquillian</groupId>

   <artifactId>arquillian-junit</artifactId>

   <version>1.0.0.Alpha5</version>

   <scope>test</scope>

</dependency>

 

Quelques annotations dans une classe de test jUnit suffisent pour
rédiger notre test d’EJB :

 

@RunWith( Arquillian.class )

public class ListeDeCoursesBeanTest \{

 

   @Deployment

   public static JavaArchive createTestArchive() \{

      return ShrinkWrap.create( JavaArchive.class,

         "test.jar")

         .addClasses( ListeDeCourses.class );

   }

 

   @EJB

   private ListeDeCourses bean;

 

   @Test

   public void listeVide() throws Exception \{

      Assert.assertTrue( bean.isEmpty( "user" ) );

   }

}

En dehors de la méthode createTestArchive, qui prépare un test.jar
contenant notre bean EJB, rien de bien surprenant. La classe ShrinkWrap
permet de composer le contenu de notre jar de test, en y incluant notre
code et, au besoin, des fichiers de ressources (par exemple un fichier
beans.xml pour activer l’injection de dépendances CDI).

Info

Si vous avez exclu le terme EJB de votre vocabulaire depuis l’époque
J2EE 1.4,  nous vous recommandons de jeter un œil rapide à la norme Java
EE 6 et EJB 3.1. Les EJB « nouvelle mode » n’ont même plus besoin de XML
ou de multiples interfaces pour embarquer du code métier. Pour en savoir
plus, courrez chez votre libraire pour commander le livre d’Antonio
Goncalves Java EE 6 et Glassfish 3 chez le même éditeur.

Pour lancer notre test, nous devons fournir à Arquillian les billes
nécessaires au lancement du serveur JavaEE cible. Si Arquillian est
développé par JBoss, il n’est pas limité à ce serveur et supporte déjà
d’autres environnements, comme OpenWebBeans ou Weld, l’implémentation de
référence de CDI que vous retrouvez dans GlassFish 3. Comme nous
cherchons à nous démarquer de Cargo, nous allons tenter d’utiliser le
mode embarqué de JBoss 6. Arquillian détecte le serveur cible en se
basant sur les librairies disponibles dans le projet; il nous suffit
donc d’ajouter les dépendances JBoss adaptées, à savoir le composant
apportant le support de JBoss 6 en mode embarqué :

 

<dependency>

    <groupId>org.jboss.arquillian.container</groupId>

    <artifactId>arquillian-jbossas-embedded-6</artifactId>

    <version>1.0.0.Alpha4</version>

    <scope>test</scope>

</dependency>

 

Cette configuration étant en place, il ne nous reste plus qu’à invoquer
le bon vieux mvn install pour que notre code EJB soit compilé et testé,
comme le reste de notre projet. Nous pouvons tout aussi bien le lancer
dans notre IDE préféré sans la moindre configuration superflue.

Si le test reste sensiblement plus long qu’un test unitaire
hors-conteneur JavaEE, nous avons réduit sensiblement la difficulté pour
tester en environnement cible. D’autant que, en utilisant des profils
adaptés, nous pourrions aussi bien exécuter le même test en déployant
sur un serveur JBoss externe ou sur un autre environnement.

 

image:illustrations/MangaVincentS.png[float="left"]

Vincent n’est pas un peu fier d’avoir réduit la complexité légendaire de
JavaEE et des tests associés à quelques API simples et cinq lignes de
XML. Ce qui nous amène à réfléchir à notre productivité dans cet
environnement : faire du développement Java EE signifie t-il forcément
faire des choses complexes, contraignantes et consommatrices de temps ?

Soyons pragmatiques, soyons productifs
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Nous sommes devenus des cadors de JavaEE, avec une automatisation
complète du processus d'assemblage et de test. Au quotidien, les choses
ne sont pourtant pas toujours aussi roses. Pour tester visuellement une
modification si mineure soit-elle sur une simple page JSP, nous devons
relancer une phase lourde d'assemblage et de déploiement. L'attente est
longue, les nerfs en subissent les conséquences et la productivité
s'écroule.

Ce n'est pas faute seulement du modèle JavaEE. S'il impose une structure
d'assemblage complexe qui alourdit notre processus, c'est à nous de
trouver des outils qui proposent des raccourcis pour plus de
productivité. Respecter la norme JavaEE pour un serveur ne signifie pas
se limiter à la norme JavaEE !

Une application web "sur place"
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Premier constat, pour tester notre modification de JSP, notre serveur
Tomcat va décompresser notre archive WAR, retrouvant ainsi exactement la
structure que le plugin war a construite dans notre répertoire de
construction (target). Le mécanisme de configuration de Tomcat permet de
pointer directement sur ce répertoire, plutôt que de passer par une
archive WAR.

Nous pouvons même faire mieux : pourquoi recopier notre JSP à chaque
modification dans le répertoire de construction alors que la structure
de l'application web existe quasiment sous src/main/webapp ? La seule
chose qui manque pour avoir une application web conforme JavaEE, ce sont
les répertoires WEB-INF/classes et WEB-INF/lib. Sous réserve d'une
configuration correcte de notre gestionnaire de code source pour ignorer
ces deux répertoires, il n'est pas compliqué de construire ces deux
répertoires manquants – et c'est d'ailleurs ce que propose le plugin war
avec sa tâche inplace.

mvn war:inplace va préparer l'application web, prête à être exécutée sur
un serveur d'application qui supporte ce mode de fonctionnement. Une
modification dans une page JSP sera alors appliquée immédiatement, _via_
le mécanisme de recompilation des JSP qui est intégré à tout serveur
JavaEE.

Une application web sans assemblage
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Nous faisons de nets progrès, mais nous devons encore invoquer une
commande Maven à chaque édition d'une classe de l'application ou
relancer le serveur lorsqu'un fichier de configuration est modifié.

Le conteneur de servlets (comme Tomcat, ce n'est pas un serveur JavaEE
complet) Jetty propose un mode de fonctionnement particulièrement adapté
à notre utilisation. Grâce à un plugin dédié, il se lance sur un projet
Maven sans nécessiter la moindre phase de préparation. Il référence
directement les bibliothèques de notre dépôt local, pointe sur notre
répertoire de compilation (target/classes) et démarre l'application web
en un temps record avec la seule commande mvn jetty:run.

Jetty va encore plus loin car il peut fonctionner en mode scrutation :
il va surveiller le répertoire de compilation et identifier une
modification sur une classe ou sur un fichier de configuration. Il
lancera alors un rechargement immédiat de l'application. La réactivité
de l'environnement de développement est alors excellente : lancement de
l'application en un minimum de temps et sans aucune préparation, prise
en compte rapide des modifications.

Ne plus sortir de l'IDE
^^^^^^^^^^^^^^^^^^^^^^^

Pour ceux qui n'apprécient pas la ligne de commande, les IDE ont
planché, de leur côté, sur le manque de productivité lié au modèle
JavaEE. Eclipse Web Tools Platform se propose par exemple de redéployer
automatiquement l'application lors d'une modification, ce qui permet de
contrôler l'impact d'une modification sans intervention manuelle. Il
suffit de configurer le serveur cible pour qu'Eclipse prenne en charge
la procédure de redéploiement.

Info

Web Tools Platform ne se limite pas à JavaEE et couvre de nombreuses
technologies liées au Web. Même si vous n'utilisez pas la fonctionnalité
de déploiement, ce module d'extension d'Eclipse sera rapidement
indispensable pour éditer convenablement les fichiers HTML, JSP, XML,
XSD, JavaScript, CSS, les contrats WSDL de services web et d’autres
formats normalisés, sans parler des petits outils bien pratiques comme
l'espion TCP/IP ou le client graphique de service web.

L'équipe de développement de m2eclipse a eu pitié des développeurs et
leur évite de devoir configurer chaque projet pour adapter la
configuration WTP à leur projet Maven. _Via_ une extension optionnelle,
m2eclipse déclarera automagiquement les modules war comme projets WTP
avec les chemins et les dépendances extraites de la configuration du
plugin war. Elle est pas belle la vie ?

image:illustrations/MangaNicolas.png[float="left"]

Histoire de ne pas faire comme tout le monde, Nicolas n'utilise pas WTP
sous Eclipse mais un petit plugin _Made in France_ : Sysdeo Tomcat,
distribué par le site de veille technologique www.eclipsetotale.com. Ce
plugin tout simple permet de lancer un serveur Tomcat, qui a l'avantage
d'être léger et rapide à démarrer et largement suffisant tant qu'on
n'exploite que les technologies de l'API servlet, ce qui est le cas
d'une grande majorité des applications web.

Ce plugin pour Eclipse a son pendant pour Mavenlink:#_ftn34[[34]],
lequel va configurer le plugin Eclipse en fonction du projet Maven et
des multiples modules impliqués. Ce plugin Eclipse a la particularité
d'exploiter la souplesse de Tomcat pour pointer sur les répertoires de
compilation de chaque module présent dans l'IDE plutôt que sur l'archive
JAR qu'il produit. Une modification dans un module est donc exploitable
sans manipulation particulière de l'IDE qui se contente de recompiler,
après que vous avez simplement cliqué sur le bouton relancer Tomcat.

Cette combinaison apporte un support limité de JavaEE, mais permet de
bénéficier d'un environnement léger et raisonnablement réactif. Elle
montre surtout que WTP a raté sa cible en apportant certes le support
JavaEE sous Eclipse, mais en choisissant la voix la moins productive.

Astuce

La seule option pour aller encore plus vite est de permettre la
modification à chaud des classes de l'application web, ce qui économise
le temps de rechargement de l'application. Le HotSwap de la machine
virtuelle Java permet cette opération avec des contraintes assez fortes,
mais un outil comme JRebel de ZeroTurnaroud permet quasiment de modifier
à chaud tous les éléments de l'application web, y compris les fichiers
de configuration des frameworks courants comme Struts ou Spring.

Il s’installe dans votre IDE sous forme de plugin et ajoute une petite
option magique. Au lancement de l’application, quelques logs indiquent
que JRebel est intégré et les plugins qu’il a activé en fonction des
technologies utilisées dans le projet (Spring, Wicket, Hibernate, etc).
En dehors de cela, rien de notable… sauf que l’application prend en
compte toutes vos modifications de code ou de configuration sans délai !

JavaEE6
~~~~~~~

image:illustrations/MangaAntonio.png[float="left"]

Venu nous passer un petit bonjour, Antonio s'amuse bien en voyant notre
configuration Maven pour construire cette belle archive d'entreprise EAR
qui nous a coûté tant d'efforts. Pourquoi ce sourire moqueur ? Antonio
travaille de son côté sur une application JavaEE6, et les évolutions
liées à cette version de la norme font de notre construction à trois
modules (EJB + WAR + EAR) un amusant pachyderme en voie de disparition.

Dans sa sixième édition majeure, la norme JavaEE fait peau neuve.
Aiguillonné par les solutions alternatives plus légères proposées par
des outils open-source, et en particulier par le succès massif de
SpringFramework, le groupe d'experts qui définit cette norme a donné une
nouvelle impulsion qui influe fortement sur la façon de développer pour
la plateforme JavaEE.

Parmi les nombreuses nouveautés introduites pour simplifier le
développement, alléger la construction d'une application ou définir des
comportements par défaut qui évitent une longue phase de configuration,
l'assemblage d'une application JavaEE a été fortement revu.

Les EJB nouvelle mouture ne doivent plus nécessairement être placés dans
une archive JAR dédiée, puis groupés dans un EAR avec l'application web
WAR. Ce jeu de poupées gigognes peut laisser place à une simple archive
WAR dans laquelle sont placés les EJB, dont les annotations suffisent à
définir le comportement vis-à-vis du conteneur. Le descripteur de
déploiement ejb-jar.xml, devenu optionnel, peut être placé directement
sous WEB-INF.

Les nouveautés de JavaEE6 vont bien au-delà de ces quelques
assouplissements d'assemblage, mais, au niveau de la construction du
projet, c'est ce qui a le plus d'impact. Nous pouvons conserver notre
code métier dans un module séparé par souci de clarification du projet,
mais nous n'avons plus besoin de définir un module juste pour construire
une archive EAR. Nous pouvons aussi déployer notre application sur un
serveur GlassFish (qui est l'implémentation de référence de la norme
JavaEE6) sans avoir besoin d'assembler notre WAR : il nous suffit de
configurer le mode inplace sur notre application web et de lancer le
serveur. Notre EJB bénéficie d'un serveur JavaEE complet, y compris la
gestion du cycle de vie, l'enrobage transactionnel ou encore la
persistance JPA.

Nous pouvons même faire encore mieux en exploitant le plugin Maven pour
GlassFishlink:#_ftn35[[35]], qui propose un mode de fonctionnement
équivalent à ce que nous avons vu pour Jetty. Il suffit de lancer une
simple commande Maven pour que le serveur soit téléchargé et qu’il
démarre en embarquant notre application telle qu'elle est dans notre
IDE, sans assemblage d'un WAR ou autre perte de temps.

Conclusion
~~~~~~~~~~

La norme JavaEE peut paraître complexe, encombrée de descripteurs XML et
d'archives imbriquées. Maven permet d'une part de prendre en charge de
manière transparente ses particularités, mais surtout d'intégrer un
ensemble de bonnes pratiques et d'outils qui simplifient les
développements ou améliorent la productivité.

Une fois de plus, Maven ne fait que catalyser, grâce à une série de
plugins officiels ou externes, les bonnes idées de développeurs du monde
entier. L'intégration en quelques lignes de XML des meilleurs outils du
moment est pour l'utilisateur final un confort sans précédent.